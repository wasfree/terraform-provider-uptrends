/*
 * Uptrends API v4
 *
 * This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uptrends

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// OperatorGroupApiService OperatorGroupApi service
type OperatorGroupApiService service

type ApiOperatorGroupAddDutyScheduleToAllMembersRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	dutySchedule *OperatorDutySchedule
}

func (r ApiOperatorGroupAddDutyScheduleToAllMembersRequest) DutySchedule(dutySchedule OperatorDutySchedule) ApiOperatorGroupAddDutyScheduleToAllMembersRequest {
	r.dutySchedule = &dutySchedule
	return r
}

func (r ApiOperatorGroupAddDutyScheduleToAllMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupAddDutyScheduleToAllMembersExecute(r)
}

/*
 * OperatorGroupAddDutyScheduleToAllMembers Adds the provided duty schedule to all operators in the group specified 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid
 * @return ApiOperatorGroupAddDutyScheduleToAllMembersRequest
 */
func (a *OperatorGroupApiService) OperatorGroupAddDutyScheduleToAllMembers(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupAddDutyScheduleToAllMembersRequest {
	return ApiOperatorGroupAddDutyScheduleToAllMembersRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupAddDutyScheduleToAllMembersExecute(r ApiOperatorGroupAddDutyScheduleToAllMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupAddDutyScheduleToAllMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/DutySchedule/AddDutyScheduleForAllMembers"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.dutySchedule == nil {
		return nil, reportError("dutySchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dutySchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupAddOperatorToOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	operatorGuid string
}


func (r ApiOperatorGroupAddOperatorToOperatorGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupAddOperatorToOperatorGroupExecute(r)
}

/*
 * OperatorGroupAddOperatorToOperatorGroup Adds the specified operator to the operator group 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to add the operator to
 * @param operatorGuid The operator Guid
 * @return ApiOperatorGroupAddOperatorToOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupAddOperatorToOperatorGroup(ctx _context.Context, operatorGroupGuid string, operatorGuid string) ApiOperatorGroupAddOperatorToOperatorGroupRequest {
	return ApiOperatorGroupAddOperatorToOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
		operatorGuid: operatorGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupAddOperatorToOperatorGroupExecute(r ApiOperatorGroupAddOperatorToOperatorGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupAddOperatorToOperatorGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Member/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupAllOperatorsInGroupOffDutyRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupAllOperatorsInGroupOffDutyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupAllOperatorsInGroupOffDutyExecute(r)
}

/*
 * OperatorGroupAllOperatorsInGroupOffDuty Set the OnDuty flag to off for all operators that are a member of the operator group specified by the operator group GUID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The operator group GUID
 * @return ApiOperatorGroupAllOperatorsInGroupOffDutyRequest
 */
func (a *OperatorGroupApiService) OperatorGroupAllOperatorsInGroupOffDuty(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupAllOperatorsInGroupOffDutyRequest {
	return ApiOperatorGroupAllOperatorsInGroupOffDutyRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupAllOperatorsInGroupOffDutyExecute(r ApiOperatorGroupAllOperatorsInGroupOffDutyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupAllOperatorsInGroupOffDuty")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/AllOperatorsOffDuty"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupAllOperatorsInGroupOnDutyRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupAllOperatorsInGroupOnDutyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupAllOperatorsInGroupOnDutyExecute(r)
}

/*
 * OperatorGroupAllOperatorsInGroupOnDuty Set the OnDuty flag to on for all operators that are a member of the operator group specified by the operator group GUID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The operator group GUID
 * @return ApiOperatorGroupAllOperatorsInGroupOnDutyRequest
 */
func (a *OperatorGroupApiService) OperatorGroupAllOperatorsInGroupOnDuty(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupAllOperatorsInGroupOnDutyRequest {
	return ApiOperatorGroupAllOperatorsInGroupOnDutyRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupAllOperatorsInGroupOnDutyExecute(r ApiOperatorGroupAllOperatorsInGroupOnDutyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupAllOperatorsInGroupOnDuty")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/AllOperatorsOnDuty"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageInfo
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	authorization *OperatorGroupAuthorization
}

func (r ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest) Authorization(authorization OperatorGroupAuthorization) ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest {
	r.authorization = &authorization
	return r
}

func (r ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest) Execute() (OperatorGroupAuthorization, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupCreateAuthorizationForOperatorGroupExecute(r)
}

/*
 * OperatorGroupCreateAuthorizationForOperatorGroup Creates a new authorization for the specified operator group
 * The AuthorizationId attribute should be omitted in the request body. The newly created authorization will be returned in the response. An authorization should be granted to an operator group. Therefore, either specify the OperatorGroupGuid attribute. The OperatorGuid attribute is not used for this endpoint
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group for which to create the new authorization.
 * @return ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupCreateAuthorizationForOperatorGroup(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest {
	return ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 * @return OperatorGroupAuthorization
 */
func (a *OperatorGroupApiService) OperatorGroupCreateAuthorizationForOperatorGroupExecute(r ApiOperatorGroupCreateAuthorizationForOperatorGroupRequest) (OperatorGroupAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OperatorGroupAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupCreateAuthorizationForOperatorGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupCreateOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroup *OperatorGroup
}

func (r ApiOperatorGroupCreateOperatorGroupRequest) OperatorGroup(operatorGroup OperatorGroup) ApiOperatorGroupCreateOperatorGroupRequest {
	r.operatorGroup = &operatorGroup
	return r
}

func (r ApiOperatorGroupCreateOperatorGroupRequest) Execute() (OperatorGroup, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupCreateOperatorGroupExecute(r)
}

/*
 * OperatorGroupCreateOperatorGroup Creates a new operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOperatorGroupCreateOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupCreateOperatorGroup(ctx _context.Context) ApiOperatorGroupCreateOperatorGroupRequest {
	return ApiOperatorGroupCreateOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OperatorGroup
 */
func (a *OperatorGroupApiService) OperatorGroupCreateOperatorGroupExecute(r ApiOperatorGroupCreateOperatorGroupRequest) (OperatorGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OperatorGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupCreateOperatorGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.operatorGroup == nil {
		return localVarReturnValue, nil, reportError("operatorGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operatorGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	authorizationGuid string
}


func (r ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupDeleteAuthorizationForOperatorGroupExecute(r)
}

/*
 * OperatorGroupDeleteAuthorizationForOperatorGroup Deletes the specified authorization for the specified operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group for which the authorization should be deleted.
 * @param authorizationGuid The Guid of the authorization that should be deleted.
 * @return ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupDeleteAuthorizationForOperatorGroup(ctx _context.Context, operatorGroupGuid string, authorizationGuid string) ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest {
	return ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
		authorizationGuid: authorizationGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupDeleteAuthorizationForOperatorGroupExecute(r ApiOperatorGroupDeleteAuthorizationForOperatorGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupDeleteAuthorizationForOperatorGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Authorization/{authorizationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationGuid"+"}", _neturl.PathEscape(parameterToString(r.authorizationGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupDeleteOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupDeleteOperatorGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupDeleteOperatorGroupExecute(r)
}

/*
 * OperatorGroupDeleteOperatorGroup Deletes the specified operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to be deleted
 * @return ApiOperatorGroupDeleteOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupDeleteOperatorGroup(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupDeleteOperatorGroupRequest {
	return ApiOperatorGroupDeleteOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupDeleteOperatorGroupExecute(r ApiOperatorGroupDeleteOperatorGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupDeleteOperatorGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupGetAllOperatorGroupsRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
}


func (r ApiOperatorGroupGetAllOperatorGroupsRequest) Execute() ([]OperatorGroup, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupGetAllOperatorGroupsExecute(r)
}

/*
 * OperatorGroupGetAllOperatorGroups Gets all operator groups
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOperatorGroupGetAllOperatorGroupsRequest
 */
func (a *OperatorGroupApiService) OperatorGroupGetAllOperatorGroups(ctx _context.Context) ApiOperatorGroupGetAllOperatorGroupsRequest {
	return ApiOperatorGroupGetAllOperatorGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []OperatorGroup
 */
func (a *OperatorGroupApiService) OperatorGroupGetAllOperatorGroupsExecute(r ApiOperatorGroupGetAllOperatorGroupsRequest) ([]OperatorGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OperatorGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupGetAllOperatorGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest) Execute() (OperatorGroupAuthorization, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupGetAuthorizationsForOperatorGroupExecute(r)
}

/*
 * OperatorGroupGetAuthorizationsForOperatorGroup Returns all authorizations for the specified operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operatorgroup for which to return authorizations.
 * @return ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupGetAuthorizationsForOperatorGroup(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest {
	return ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 * @return OperatorGroupAuthorization
 */
func (a *OperatorGroupApiService) OperatorGroupGetAuthorizationsForOperatorGroupExecute(r ApiOperatorGroupGetAuthorizationsForOperatorGroupRequest) (OperatorGroupAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OperatorGroupAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupGetAuthorizationsForOperatorGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupGetOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupGetOperatorGroupRequest) Execute() (OperatorGroup, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupGetOperatorGroupExecute(r)
}

/*
 * OperatorGroupGetOperatorGroup Gets the details of a operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to be retrieved
 * @return ApiOperatorGroupGetOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupGetOperatorGroup(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupGetOperatorGroupRequest {
	return ApiOperatorGroupGetOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 * @return OperatorGroup
 */
func (a *OperatorGroupApiService) OperatorGroupGetOperatorGroupExecute(r ApiOperatorGroupGetOperatorGroupRequest) (OperatorGroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OperatorGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupGetOperatorGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupGetOperatorGroupMembersRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
}


func (r ApiOperatorGroupGetOperatorGroupMembersRequest) Execute() (OperatorGroupMember, *_nethttp.Response, error) {
	return r.ApiService.OperatorGroupGetOperatorGroupMembersExecute(r)
}

/*
 * OperatorGroupGetOperatorGroupMembers Gets a list of all members of an operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to retrieve the members for
 * @return ApiOperatorGroupGetOperatorGroupMembersRequest
 */
func (a *OperatorGroupApiService) OperatorGroupGetOperatorGroupMembers(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupGetOperatorGroupMembersRequest {
	return ApiOperatorGroupGetOperatorGroupMembersRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 * @return OperatorGroupMember
 */
func (a *OperatorGroupApiService) OperatorGroupGetOperatorGroupMembersExecute(r ApiOperatorGroupGetOperatorGroupMembersRequest) (OperatorGroupMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OperatorGroupMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupGetOperatorGroupMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Member"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	operatorGuid string
}


func (r ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupRemoveOperatorFromOperatorGroupExecute(r)
}

/*
 * OperatorGroupRemoveOperatorFromOperatorGroup Removes the specified operator from the operator group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to remove the operator from
 * @param operatorGuid The operator Guid to be removed
 * @return ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupRemoveOperatorFromOperatorGroup(ctx _context.Context, operatorGroupGuid string, operatorGuid string) ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest {
	return ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
		operatorGuid: operatorGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupRemoveOperatorFromOperatorGroupExecute(r ApiOperatorGroupRemoveOperatorFromOperatorGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupRemoveOperatorFromOperatorGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}/Member/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGroupUpdateOperatorGroupRequest struct {
	ctx _context.Context
	ApiService *OperatorGroupApiService
	operatorGroupGuid string
	operatorGroup *OperatorGroup
}

func (r ApiOperatorGroupUpdateOperatorGroupRequest) OperatorGroup(operatorGroup OperatorGroup) ApiOperatorGroupUpdateOperatorGroupRequest {
	r.operatorGroup = &operatorGroup
	return r
}

func (r ApiOperatorGroupUpdateOperatorGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorGroupUpdateOperatorGroupExecute(r)
}

/*
 * OperatorGroupUpdateOperatorGroup Updates the operator group with the Guid specified
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param operatorGroupGuid The Guid of the operator group to be updated
 * @return ApiOperatorGroupUpdateOperatorGroupRequest
 */
func (a *OperatorGroupApiService) OperatorGroupUpdateOperatorGroup(ctx _context.Context, operatorGroupGuid string) ApiOperatorGroupUpdateOperatorGroupRequest {
	return ApiOperatorGroupUpdateOperatorGroupRequest{
		ApiService: a,
		ctx: ctx,
		operatorGroupGuid: operatorGroupGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *OperatorGroupApiService) OperatorGroupUpdateOperatorGroupExecute(r ApiOperatorGroupUpdateOperatorGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorGroupApiService.OperatorGroupUpdateOperatorGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/OperatorGroup/{operatorGroupGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.operatorGroup == nil {
		return nil, reportError("operatorGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operatorGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
