/*
Uptrends API v4

This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uptrends

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PublicStatusPageApiService PublicStatusPageApi service
type PublicStatusPageApiService service

type ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	authorization *PSPAuthorization
}

// The complete definition of the authorization that should be created.
func (r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) Authorization(authorization PSPAuthorization) ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest {
	r.authorization = &authorization
	return r
}

func (r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) Execute() (*PSPAuthorization, *http.Response, error) {
	return r.ApiService.PublicStatusPageAddAuthorizationToPublicStatusPageExecute(r)
}

/*
PublicStatusPageAddAuthorizationToPublicStatusPage Creates a new authorization for the specified public status page.

The AuthorizationId attribute should be omitted in the request body. The newly created authorization will be returned in the response. An authorization should be granted to either an individual operator, or an operator group. Therefore, either specify the OperatorGuid attribute or the OperatorGroupGuid attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page.
 @return ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageAddAuthorizationToPublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest {
	return ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
//  @return PSPAuthorization
func (a *PublicStatusPageApiService) PublicStatusPageAddAuthorizationToPublicStatusPageExecute(r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) (*PSPAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PSPAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageAddAuthorizationToPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageDeletePublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}

func (r ApiPublicStatusPageDeletePublicStatusPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublicStatusPageDeletePublicStatusPageExecute(r)
}

/*
PublicStatusPageDeletePublicStatusPage Deletes the definition of the specified public status page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page that should be updated.
 @return ApiPublicStatusPageDeletePublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageDeletePublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPageDeletePublicStatusPageRequest {
	return ApiPublicStatusPageDeletePublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
func (a *PublicStatusPageApiService) PublicStatusPageDeletePublicStatusPageExecute(r ApiPublicStatusPageDeletePublicStatusPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageDeletePublicStatusPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}

func (r ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest) Execute() ([]PSPAuthorization, *http.Response, error) {
	return r.ApiService.PublicStatusPageGetAuthorizationsForPublicStatusPageExecute(r)
}

/*
PublicStatusPageGetAuthorizationsForPublicStatusPage Returns all authorizations for the specified public status page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page.
 @return ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageGetAuthorizationsForPublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest {
	return ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
//  @return []PSPAuthorization
func (a *PublicStatusPageApiService) PublicStatusPageGetAuthorizationsForPublicStatusPageExecute(r ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest) ([]PSPAuthorization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PSPAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetAuthorizationsForPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}

func (r ApiPublicStatusPageGetPublicStatusPageRequest) Execute() (*PublicStatusPage, *http.Response, error) {
	return r.ApiService.PublicStatusPageGetPublicStatusPageExecute(r)
}

/*
PublicStatusPageGetPublicStatusPage Returns the definition of the specified public status page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the requested public status page.
 @return ApiPublicStatusPageGetPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPageGetPublicStatusPageRequest {
	return ApiPublicStatusPageGetPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
//  @return PublicStatusPage
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPageExecute(r ApiPublicStatusPageGetPublicStatusPageRequest) (*PublicStatusPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetPublicStatusPagesRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
}

func (r ApiPublicStatusPageGetPublicStatusPagesRequest) Execute() ([]PublicStatusPage, *http.Response, error) {
	return r.ApiService.PublicStatusPageGetPublicStatusPagesExecute(r)
}

/*
PublicStatusPageGetPublicStatusPages Returns the definition of all public status pages available in the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublicStatusPageGetPublicStatusPagesRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPages(ctx context.Context) ApiPublicStatusPageGetPublicStatusPagesRequest {
	return ApiPublicStatusPageGetPublicStatusPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PublicStatusPage
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPagesExecute(r ApiPublicStatusPageGetPublicStatusPagesRequest) ([]PublicStatusPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetPublicStatusPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPagePatchPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	publicStatusPage *PublicStatusPage
}

// The partial definition for the public status page that should be updated.
func (r ApiPublicStatusPagePatchPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePatchPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePatchPublicStatusPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublicStatusPagePatchPublicStatusPageExecute(r)
}

/*
PublicStatusPagePatchPublicStatusPage Partially updates the definition of the specified public status page.

This methods accepts parts of a public status page definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back these changes only using this PATCH method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page that should be updated.
 @return ApiPublicStatusPagePatchPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPagePatchPublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPagePatchPublicStatusPageRequest {
	return ApiPublicStatusPagePatchPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
func (a *PublicStatusPageApiService) PublicStatusPagePatchPublicStatusPageExecute(r ApiPublicStatusPagePatchPublicStatusPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePatchPublicStatusPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPagePostPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPage *PublicStatusPage
}

// The complete definition for the public status page that should be updated.
func (r ApiPublicStatusPagePostPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePostPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePostPublicStatusPageRequest) Execute() (*PublicStatusPage, *http.Response, error) {
	return r.ApiService.PublicStatusPagePostPublicStatusPageExecute(r)
}

/*
PublicStatusPagePostPublicStatusPage Creates a new public status page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublicStatusPagePostPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPagePostPublicStatusPage(ctx context.Context) ApiPublicStatusPagePostPublicStatusPageRequest {
	return ApiPublicStatusPagePostPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PublicStatusPage
func (a *PublicStatusPageApiService) PublicStatusPagePostPublicStatusPageExecute(r ApiPublicStatusPagePostPublicStatusPageRequest) (*PublicStatusPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePostPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPagePutPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	publicStatusPage *PublicStatusPage
}

// The complete definition for the public status page that should be updated.
func (r ApiPublicStatusPagePutPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePutPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePutPublicStatusPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublicStatusPagePutPublicStatusPageExecute(r)
}

/*
PublicStatusPagePutPublicStatusPage Updates the definition of the specified public status page.

This methods only accepts a complete public status page definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back the updated definition using this PUT method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page that should be updated.
 @return ApiPublicStatusPagePutPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPagePutPublicStatusPage(ctx context.Context, publicStatusPageGuid string) ApiPublicStatusPagePutPublicStatusPageRequest {
	return ApiPublicStatusPagePutPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

// Execute executes the request
func (a *PublicStatusPageApiService) PublicStatusPagePutPublicStatusPageExecute(r ApiPublicStatusPagePutPublicStatusPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePutPublicStatusPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest struct {
	ctx context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	authorizationGuid string
}

func (r ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublicStatusPageRemoveAuthorizationFromPublicStatusPageExecute(r)
}

/*
PublicStatusPageRemoveAuthorizationFromPublicStatusPage Removes an authorization from a public status page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param publicStatusPageGuid The Guid of the public status page.
 @param authorizationGuid The Guid of the authorization.
 @return ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest
*/
func (a *PublicStatusPageApiService) PublicStatusPageRemoveAuthorizationFromPublicStatusPage(ctx context.Context, publicStatusPageGuid string, authorizationGuid string) ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest {
	return ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
		authorizationGuid: authorizationGuid,
	}
}

// Execute executes the request
func (a *PublicStatusPageApiService) PublicStatusPageRemoveAuthorizationFromPublicStatusPageExecute(r ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageRemoveAuthorizationFromPublicStatusPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization/{authorizationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", url.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationGuid"+"}", url.PathEscape(parameterToString(r.authorizationGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
