/*
 * Uptrends API v4
 *
 * This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uptrends

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PublicStatusPageApiService PublicStatusPageApi service
type PublicStatusPageApiService service

type ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	authorization *PSPAuthorization
}

func (r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) Authorization(authorization PSPAuthorization) ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest {
	r.authorization = &authorization
	return r
}

func (r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) Execute() (PSPAuthorization, *_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageAddAuthorizationToPublicStatusPageExecute(r)
}

/*
 * PublicStatusPageAddAuthorizationToPublicStatusPage Creates a new authorization for the specified public status page.
 * The AuthorizationId attribute should be omitted in the request body. The newly created authorization will be returned in the response. An authorization should be granted to either an individual operator, or an operator group. Therefore, either specify the OperatorGuid attribute or the OperatorGroupGuid attribute.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page.
 * @return ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageAddAuthorizationToPublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest {
	return ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 * @return PSPAuthorization
 */
func (a *PublicStatusPageApiService) PublicStatusPageAddAuthorizationToPublicStatusPageExecute(r ApiPublicStatusPageAddAuthorizationToPublicStatusPageRequest) (PSPAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PSPAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageAddAuthorizationToPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorization
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageDeletePublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}


func (r ApiPublicStatusPageDeletePublicStatusPageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageDeletePublicStatusPageExecute(r)
}

/*
 * PublicStatusPageDeletePublicStatusPage Deletes the definition of the specified public status page.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page that should be updated.
 * @return ApiPublicStatusPageDeletePublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageDeletePublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPageDeletePublicStatusPageRequest {
	return ApiPublicStatusPageDeletePublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PublicStatusPageApiService) PublicStatusPageDeletePublicStatusPageExecute(r ApiPublicStatusPageDeletePublicStatusPageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageDeletePublicStatusPage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}


func (r ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest) Execute() ([]PSPAuthorization, *_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageGetAuthorizationsForPublicStatusPageExecute(r)
}

/*
 * PublicStatusPageGetAuthorizationsForPublicStatusPage Returns all authorizations for the specified public status page.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page.
 * @return ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetAuthorizationsForPublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest {
	return ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 * @return []PSPAuthorization
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetAuthorizationsForPublicStatusPageExecute(r ApiPublicStatusPageGetAuthorizationsForPublicStatusPageRequest) ([]PSPAuthorization, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []PSPAuthorization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetAuthorizationsForPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
}


func (r ApiPublicStatusPageGetPublicStatusPageRequest) Execute() (PublicStatusPage, *_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageGetPublicStatusPageExecute(r)
}

/*
 * PublicStatusPageGetPublicStatusPage Returns the definition of the specified public status page.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the requested public status page.
 * @return ApiPublicStatusPageGetPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPageGetPublicStatusPageRequest {
	return ApiPublicStatusPageGetPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 * @return PublicStatusPage
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPageExecute(r ApiPublicStatusPageGetPublicStatusPageRequest) (PublicStatusPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPageGetPublicStatusPagesRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
}


func (r ApiPublicStatusPageGetPublicStatusPagesRequest) Execute() ([]PublicStatusPage, *_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageGetPublicStatusPagesExecute(r)
}

/*
 * PublicStatusPageGetPublicStatusPages Returns the definition of all public status pages available in the account.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPublicStatusPageGetPublicStatusPagesRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPages(ctx _context.Context) ApiPublicStatusPageGetPublicStatusPagesRequest {
	return ApiPublicStatusPageGetPublicStatusPagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []PublicStatusPage
 */
func (a *PublicStatusPageApiService) PublicStatusPageGetPublicStatusPagesExecute(r ApiPublicStatusPageGetPublicStatusPagesRequest) ([]PublicStatusPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageGetPublicStatusPages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPagePatchPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	publicStatusPage *PublicStatusPage
}

func (r ApiPublicStatusPagePatchPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePatchPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePatchPublicStatusPageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicStatusPagePatchPublicStatusPageExecute(r)
}

/*
 * PublicStatusPagePatchPublicStatusPage Partially updates the definition of the specified public status page.
 * This methods accepts parts of a public status page definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back these changes only using this PATCH method.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page that should be updated.
 * @return ApiPublicStatusPagePatchPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPagePatchPublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPagePatchPublicStatusPageRequest {
	return ApiPublicStatusPagePatchPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PublicStatusPageApiService) PublicStatusPagePatchPublicStatusPageExecute(r ApiPublicStatusPagePatchPublicStatusPageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePatchPublicStatusPage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.publicStatusPage == nil {
		return nil, reportError("publicStatusPage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPagePostPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPage *PublicStatusPage
}

func (r ApiPublicStatusPagePostPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePostPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePostPublicStatusPageRequest) Execute() (PublicStatusPage, *_nethttp.Response, error) {
	return r.ApiService.PublicStatusPagePostPublicStatusPageExecute(r)
}

/*
 * PublicStatusPagePostPublicStatusPage Creates a new public status page.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPublicStatusPagePostPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPagePostPublicStatusPage(ctx _context.Context) ApiPublicStatusPagePostPublicStatusPageRequest {
	return ApiPublicStatusPagePostPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PublicStatusPage
 */
func (a *PublicStatusPageApiService) PublicStatusPagePostPublicStatusPageExecute(r ApiPublicStatusPagePostPublicStatusPageRequest) (PublicStatusPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PublicStatusPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePostPublicStatusPage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.publicStatusPage == nil {
		return localVarReturnValue, nil, reportError("publicStatusPage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicStatusPagePutPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	publicStatusPage *PublicStatusPage
}

func (r ApiPublicStatusPagePutPublicStatusPageRequest) PublicStatusPage(publicStatusPage PublicStatusPage) ApiPublicStatusPagePutPublicStatusPageRequest {
	r.publicStatusPage = &publicStatusPage
	return r
}

func (r ApiPublicStatusPagePutPublicStatusPageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicStatusPagePutPublicStatusPageExecute(r)
}

/*
 * PublicStatusPagePutPublicStatusPage Updates the definition of the specified public status page.
 * This methods only accepts a complete public status page definition. We recommend retrieving the existing definition first (using the GET method). You can then process the changes you want to make and send back the updated definition using this PUT method.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page that should be updated.
 * @return ApiPublicStatusPagePutPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPagePutPublicStatusPage(ctx _context.Context, publicStatusPageGuid string) ApiPublicStatusPagePutPublicStatusPageRequest {
	return ApiPublicStatusPagePutPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PublicStatusPageApiService) PublicStatusPagePutPublicStatusPageExecute(r ApiPublicStatusPagePutPublicStatusPageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPagePutPublicStatusPage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.publicStatusPage == nil {
		return nil, reportError("publicStatusPage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicStatusPage
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest struct {
	ctx _context.Context
	ApiService *PublicStatusPageApiService
	publicStatusPageGuid string
	authorizationGuid string
}


func (r ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicStatusPageRemoveAuthorizationFromPublicStatusPageExecute(r)
}

/*
 * PublicStatusPageRemoveAuthorizationFromPublicStatusPage Removes an authorization from a public status page.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param publicStatusPageGuid The Guid of the public status page.
 * @param authorizationGuid The Guid of the authorization.
 * @return ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest
 */
func (a *PublicStatusPageApiService) PublicStatusPageRemoveAuthorizationFromPublicStatusPage(ctx _context.Context, publicStatusPageGuid string, authorizationGuid string) ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest {
	return ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest{
		ApiService: a,
		ctx: ctx,
		publicStatusPageGuid: publicStatusPageGuid,
		authorizationGuid: authorizationGuid,
	}
}

/*
 * Execute executes the request
 */
func (a *PublicStatusPageApiService) PublicStatusPageRemoveAuthorizationFromPublicStatusPageExecute(r ApiPublicStatusPageRemoveAuthorizationFromPublicStatusPageRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicStatusPageApiService.PublicStatusPageRemoveAuthorizationFromPublicStatusPage")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PublicStatusPage/{publicStatusPageGuid}/Authorization/{authorizationGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"publicStatusPageGuid"+"}", _neturl.PathEscape(parameterToString(r.publicStatusPageGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationGuid"+"}", _neturl.PathEscape(parameterToString(r.authorizationGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
