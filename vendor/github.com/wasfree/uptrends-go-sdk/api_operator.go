/*
Uptrends API v4

This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uptrends

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// OperatorApiService OperatorApi service
type OperatorApiService service

type ApiOperatorAddDutyPeriodForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	schedule *OperatorDutySchedule
}

// The duty schedule to add
func (r ApiOperatorAddDutyPeriodForOperatorRequest) Schedule(schedule OperatorDutySchedule) ApiOperatorAddDutyPeriodForOperatorRequest {
	r.schedule = &schedule
	return r
}

func (r ApiOperatorAddDutyPeriodForOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorAddDutyPeriodForOperatorExecute(r)
}

/*
OperatorAddDutyPeriodForOperator Adds a duty schedule to the specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator to add the duty schedule to
 @return ApiOperatorAddDutyPeriodForOperatorRequest
*/
func (a *OperatorApiService) OperatorAddDutyPeriodForOperator(ctx _context.Context, operatorGuid string) ApiOperatorAddDutyPeriodForOperatorRequest {
	return ApiOperatorAddDutyPeriodForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorAddDutyPeriodForOperatorExecute(r ApiOperatorAddDutyPeriodForOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorAddDutyPeriodForOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/DutySchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.schedule == nil {
		return nil, reportError("schedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorCreateOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	uptrendsOperator *Operator
}

// The details of the operator to create
func (r ApiOperatorCreateOperatorRequest) UptrendsOperator(uptrendsOperator Operator) ApiOperatorCreateOperatorRequest {
	r.uptrendsOperator = &uptrendsOperator
	return r
}

func (r ApiOperatorCreateOperatorRequest) Execute() (Operator, *_nethttp.Response, error) {
	return r.ApiService.OperatorCreateOperatorExecute(r)
}

/*
OperatorCreateOperator Creates a new operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOperatorCreateOperatorRequest
*/
func (a *OperatorApiService) OperatorCreateOperator(ctx _context.Context) ApiOperatorCreateOperatorRequest {
	return ApiOperatorCreateOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Operator
func (a *OperatorApiService) OperatorCreateOperatorExecute(r ApiOperatorCreateOperatorRequest) (Operator, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Operator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorCreateOperator")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uptrendsOperator == nil {
		return localVarReturnValue, nil, reportError("uptrendsOperator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uptrendsOperator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorDeleteAuthorizationForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	authorizationType string
}


func (r ApiOperatorDeleteAuthorizationForOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorDeleteAuthorizationForOperatorExecute(r)
}

/*
OperatorDeleteAuthorizationForOperator Removes the specified authorization of this operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator
 @param authorizationType The type of authorization
 @return ApiOperatorDeleteAuthorizationForOperatorRequest
*/
func (a *OperatorApiService) OperatorDeleteAuthorizationForOperator(ctx _context.Context, operatorGuid string, authorizationType string) ApiOperatorDeleteAuthorizationForOperatorRequest {
	return ApiOperatorDeleteAuthorizationForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
		authorizationType: authorizationType,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorDeleteAuthorizationForOperatorExecute(r ApiOperatorDeleteAuthorizationForOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorDeleteAuthorizationForOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/Authorization/{authorizationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationType"+"}", _neturl.PathEscape(parameterToString(r.authorizationType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorDeleteDutyScheduleFromOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	dutyScheduleId int32
}


func (r ApiOperatorDeleteDutyScheduleFromOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorDeleteDutyScheduleFromOperatorExecute(r)
}

/*
OperatorDeleteDutyScheduleFromOperator Deletes the specified duty schedule of the specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid
 @param dutyScheduleId
 @return ApiOperatorDeleteDutyScheduleFromOperatorRequest
*/
func (a *OperatorApiService) OperatorDeleteDutyScheduleFromOperator(ctx _context.Context, operatorGuid string, dutyScheduleId int32) ApiOperatorDeleteDutyScheduleFromOperatorRequest {
	return ApiOperatorDeleteDutyScheduleFromOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
		dutyScheduleId: dutyScheduleId,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorDeleteDutyScheduleFromOperatorExecute(r ApiOperatorDeleteDutyScheduleFromOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorDeleteDutyScheduleFromOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/DutySchedule/{dutyScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dutyScheduleId"+"}", _neturl.PathEscape(parameterToString(r.dutyScheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorDeleteOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
}


func (r ApiOperatorDeleteOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorDeleteOperatorExecute(r)
}

/*
OperatorDeleteOperator Deletes an existing operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator to delete
 @return ApiOperatorDeleteOperatorRequest
*/
func (a *OperatorApiService) OperatorDeleteOperator(ctx _context.Context, operatorGuid string) ApiOperatorDeleteOperatorRequest {
	return ApiOperatorDeleteOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorDeleteOperatorExecute(r ApiOperatorDeleteOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorDeleteOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorGetAllOperatorsRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
}


func (r ApiOperatorGetAllOperatorsRequest) Execute() ([]Operator, *_nethttp.Response, error) {
	return r.ApiService.OperatorGetAllOperatorsExecute(r)
}

/*
OperatorGetAllOperators Gets a list of all operators.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOperatorGetAllOperatorsRequest
*/
func (a *OperatorApiService) OperatorGetAllOperators(ctx _context.Context) ApiOperatorGetAllOperatorsRequest {
	return ApiOperatorGetAllOperatorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Operator
func (a *OperatorApiService) OperatorGetAllOperatorsExecute(r ApiOperatorGetAllOperatorsRequest) ([]Operator, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Operator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorGetAllOperators")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGetAuthorizationsForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
}


func (r ApiOperatorGetAuthorizationsForOperatorRequest) Execute() ([]OperatorAuthorizationType, *_nethttp.Response, error) {
	return r.ApiService.OperatorGetAuthorizationsForOperatorExecute(r)
}

/*
OperatorGetAuthorizationsForOperator Gets all authorizations for the specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator
 @return ApiOperatorGetAuthorizationsForOperatorRequest
*/
func (a *OperatorApiService) OperatorGetAuthorizationsForOperator(ctx _context.Context, operatorGuid string) ApiOperatorGetAuthorizationsForOperatorRequest {
	return ApiOperatorGetAuthorizationsForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
//  @return []OperatorAuthorizationType
func (a *OperatorApiService) OperatorGetAuthorizationsForOperatorExecute(r ApiOperatorGetAuthorizationsForOperatorRequest) ([]OperatorAuthorizationType, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OperatorAuthorizationType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorGetAuthorizationsForOperator")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/Authorization"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGetDutyScheduleForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
}


func (r ApiOperatorGetDutyScheduleForOperatorRequest) Execute() ([]OperatorDutySchedule, *_nethttp.Response, error) {
	return r.ApiService.OperatorGetDutyScheduleForOperatorExecute(r)
}

/*
OperatorGetDutyScheduleForOperator Gets the duty schedules for an specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator to get the duty schedule for
 @return ApiOperatorGetDutyScheduleForOperatorRequest
*/
func (a *OperatorApiService) OperatorGetDutyScheduleForOperator(ctx _context.Context, operatorGuid string) ApiOperatorGetDutyScheduleForOperatorRequest {
	return ApiOperatorGetDutyScheduleForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
//  @return []OperatorDutySchedule
func (a *OperatorApiService) OperatorGetDutyScheduleForOperatorExecute(r ApiOperatorGetDutyScheduleForOperatorRequest) ([]OperatorDutySchedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OperatorDutySchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorGetDutyScheduleForOperator")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/DutySchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGetOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
}


func (r ApiOperatorGetOperatorRequest) Execute() (Operator, *_nethttp.Response, error) {
	return r.ApiService.OperatorGetOperatorExecute(r)
}

/*
OperatorGetOperator Gets the details of the operator with the provided OperatorGuid.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator for which to retrieve the details
 @return ApiOperatorGetOperatorRequest
*/
func (a *OperatorApiService) OperatorGetOperator(ctx _context.Context, operatorGuid string) ApiOperatorGetOperatorRequest {
	return ApiOperatorGetOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
//  @return Operator
func (a *OperatorApiService) OperatorGetOperatorExecute(r ApiOperatorGetOperatorRequest) (Operator, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Operator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorGetOperator")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorGetOperatorGroupsForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
}


func (r ApiOperatorGetOperatorGroupsForOperatorRequest) Execute() ([]OperatorMember, *_nethttp.Response, error) {
	return r.ApiService.OperatorGetOperatorGroupsForOperatorExecute(r)
}

/*
OperatorGetOperatorGroupsForOperator Gets a list of all operator groups for the specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator for which to retrieve the operator group guids
 @return ApiOperatorGetOperatorGroupsForOperatorRequest
*/
func (a *OperatorApiService) OperatorGetOperatorGroupsForOperator(ctx _context.Context, operatorGuid string) ApiOperatorGetOperatorGroupsForOperatorRequest {
	return ApiOperatorGetOperatorGroupsForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
//  @return []OperatorMember
func (a *OperatorApiService) OperatorGetOperatorGroupsForOperatorExecute(r ApiOperatorGetOperatorGroupsForOperatorRequest) ([]OperatorMember, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OperatorMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorGetOperatorGroupsForOperator")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/OperatorGroup"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOperatorPostAuthorizationForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	authorizationType string
}


func (r ApiOperatorPostAuthorizationForOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorPostAuthorizationForOperatorExecute(r)
}

/*
OperatorPostAuthorizationForOperator Assigns the specified authorization to this operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator
 @param authorizationType The type of authorization
 @return ApiOperatorPostAuthorizationForOperatorRequest
*/
func (a *OperatorApiService) OperatorPostAuthorizationForOperator(ctx _context.Context, operatorGuid string, authorizationType string) ApiOperatorPostAuthorizationForOperatorRequest {
	return ApiOperatorPostAuthorizationForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
		authorizationType: authorizationType,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorPostAuthorizationForOperatorExecute(r ApiOperatorPostAuthorizationForOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorPostAuthorizationForOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/Authorization/{authorizationType}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"authorizationType"+"}", _neturl.PathEscape(parameterToString(r.authorizationType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorUpdateDutyPeriodForOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	dutyScheduleId int32
	schedule *OperatorDutySchedule
}

func (r ApiOperatorUpdateDutyPeriodForOperatorRequest) Schedule(schedule OperatorDutySchedule) ApiOperatorUpdateDutyPeriodForOperatorRequest {
	r.schedule = &schedule
	return r
}

func (r ApiOperatorUpdateDutyPeriodForOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorUpdateDutyPeriodForOperatorExecute(r)
}

/*
OperatorUpdateDutyPeriodForOperator Updates the specified duty schedule of the specified operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid
 @param dutyScheduleId
 @return ApiOperatorUpdateDutyPeriodForOperatorRequest
*/
func (a *OperatorApiService) OperatorUpdateDutyPeriodForOperator(ctx _context.Context, operatorGuid string, dutyScheduleId int32) ApiOperatorUpdateDutyPeriodForOperatorRequest {
	return ApiOperatorUpdateDutyPeriodForOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
		dutyScheduleId: dutyScheduleId,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorUpdateDutyPeriodForOperatorExecute(r ApiOperatorUpdateDutyPeriodForOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorUpdateDutyPeriodForOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}/DutySchedule/{dutyScheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dutyScheduleId"+"}", _neturl.PathEscape(parameterToString(r.dutyScheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.schedule == nil {
		return nil, reportError("schedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorUpdateOperatorRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	uptrendsOperator *Operator
}

// The updated details of the operator
func (r ApiOperatorUpdateOperatorRequest) UptrendsOperator(uptrendsOperator Operator) ApiOperatorUpdateOperatorRequest {
	r.uptrendsOperator = &uptrendsOperator
	return r
}

func (r ApiOperatorUpdateOperatorRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorUpdateOperatorExecute(r)
}

/*
OperatorUpdateOperator Updates an existing operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator to update
 @return ApiOperatorUpdateOperatorRequest
*/
func (a *OperatorApiService) OperatorUpdateOperator(ctx _context.Context, operatorGuid string) ApiOperatorUpdateOperatorRequest {
	return ApiOperatorUpdateOperatorRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorUpdateOperatorExecute(r ApiOperatorUpdateOperatorRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorUpdateOperator")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uptrendsOperator == nil {
		return nil, reportError("uptrendsOperator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uptrendsOperator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOperatorUpdateOperatorWithPatchRequest struct {
	ctx _context.Context
	ApiService *OperatorApiService
	operatorGuid string
	uptrendsOperator *Operator
}

// The updated details of the operator
func (r ApiOperatorUpdateOperatorWithPatchRequest) UptrendsOperator(uptrendsOperator Operator) ApiOperatorUpdateOperatorWithPatchRequest {
	r.uptrendsOperator = &uptrendsOperator
	return r
}

func (r ApiOperatorUpdateOperatorWithPatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OperatorUpdateOperatorWithPatchExecute(r)
}

/*
OperatorUpdateOperatorWithPatch Updates an existing operator.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param operatorGuid The Guid of the operator to update
 @return ApiOperatorUpdateOperatorWithPatchRequest
*/
func (a *OperatorApiService) OperatorUpdateOperatorWithPatch(ctx _context.Context, operatorGuid string) ApiOperatorUpdateOperatorWithPatchRequest {
	return ApiOperatorUpdateOperatorWithPatchRequest{
		ApiService: a,
		ctx: ctx,
		operatorGuid: operatorGuid,
	}
}

// Execute executes the request
func (a *OperatorApiService) OperatorUpdateOperatorWithPatchExecute(r ApiOperatorUpdateOperatorWithPatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatorApiService.OperatorUpdateOperatorWithPatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Operator/{operatorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"operatorGuid"+"}", _neturl.PathEscape(parameterToString(r.operatorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.uptrendsOperator == nil {
		return nil, reportError("uptrendsOperator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uptrendsOperator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
