/*
Uptrends API v4

This document describes Uptrends API version 4. This Swagger environment also lets you execute API methods directly.  Please note that this is not a sandbox environment: these API methods operate directly on your actual Uptrends account.  For more information, please visit https://www.uptrends.com/api.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uptrends

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// MonitorCheckApiService MonitorCheckApi service
type MonitorCheckApiService service

type ApiMonitorCheckGetAccountMonitorChecksRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	errorLevel *string
	showPartialMeasurements *bool
	cursor *string
	sorting *string
	take *int32
	start *time.Time
	end *time.Time
	presetPeriod *string
}

// Error level filter that should be applied. (default &#x3D; NoError and above)
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) ErrorLevel(errorLevel string) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.errorLevel = &errorLevel
	return r
}
// Show partial measurements from concurrent monitors
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) ShowPartialMeasurements(showPartialMeasurements bool) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.showPartialMeasurements = &showPartialMeasurements
	return r
}
// A cursor value that should be used for traversing the dataset.
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) Cursor(cursor string) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.cursor = &cursor
	return r
}
// Sorting direction based on timestamp.
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) Sorting(sorting string) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.sorting = &sorting
	return r
}
// The number of records to return (Max value &#x3D; 100)
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) Take(take int32) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.take = &take
	return r
}
// The start of a custom period (can&#39;t be used together with the PresetPeriod parameter)
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) Start(start time.Time) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.start = &start
	return r
}
// The end of a custom period
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) End(end time.Time) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.end = &end
	return r
}
// The requested time period.
func (r ApiMonitorCheckGetAccountMonitorChecksRequest) PresetPeriod(presetPeriod string) ApiMonitorCheckGetAccountMonitorChecksRequest {
	r.presetPeriod = &presetPeriod
	return r
}

func (r ApiMonitorCheckGetAccountMonitorChecksRequest) Execute() (MonitorCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetAccountMonitorChecksExecute(r)
}

/*
MonitorCheckGetAccountMonitorChecks Returns all monitor check data.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMonitorCheckGetAccountMonitorChecksRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetAccountMonitorChecks(ctx _context.Context) ApiMonitorCheckGetAccountMonitorChecksRequest {
	return ApiMonitorCheckGetAccountMonitorChecksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MonitorCheckResponse
func (a *MonitorCheckApiService) MonitorCheckGetAccountMonitorChecksExecute(r ApiMonitorCheckGetAccountMonitorChecksRequest) (MonitorCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MonitorCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetAccountMonitorChecks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.errorLevel != nil {
		localVarQueryParams.Add("ErrorLevel", parameterToString(*r.errorLevel, ""))
	}
	if r.showPartialMeasurements != nil {
		localVarQueryParams.Add("ShowPartialMeasurements", parameterToString(*r.showPartialMeasurements, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("Cursor", parameterToString(*r.cursor, ""))
	}
	if r.sorting != nil {
		localVarQueryParams.Add("Sorting", parameterToString(*r.sorting, ""))
	}
	if r.take != nil {
		localVarQueryParams.Add("Take", parameterToString(*r.take, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("Start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("End", parameterToString(*r.end, ""))
	}
	if r.presetPeriod != nil {
		localVarQueryParams.Add("PresetPeriod", parameterToString(*r.presetPeriod, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
}


func (r ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest) Execute() (MonitorCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetConcurrentMonitorPartialChecksExecute(r)
}

/*
MonitorCheckGetConcurrentMonitorPartialChecks Gets all partial checks for a concurrent monitor check

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the partial checks for.
 @return ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetConcurrentMonitorPartialChecks(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest {
	return ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return MonitorCheckResponse
func (a *MonitorCheckApiService) MonitorCheckGetConcurrentMonitorPartialChecksExecute(r ApiMonitorCheckGetConcurrentMonitorPartialChecksRequest) (MonitorCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MonitorCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetConcurrentMonitorPartialChecks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/Concurrent"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetConsoleLogInfoRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
	step *int32
}

// For transactions only: the transaction step to get the console log for.
func (r ApiMonitorCheckGetConsoleLogInfoRequest) Step(step int32) ApiMonitorCheckGetConsoleLogInfoRequest {
	r.step = &step
	return r
}

func (r ApiMonitorCheckGetConsoleLogInfoRequest) Execute() (WaterfallResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetConsoleLogInfoExecute(r)
}

/*
MonitorCheckGetConsoleLogInfo Returns console log information for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetConsoleLogInfoRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetConsoleLogInfo(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetConsoleLogInfoRequest {
	return ApiMonitorCheckGetConsoleLogInfoRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return WaterfallResponse
func (a *MonitorCheckApiService) MonitorCheckGetConsoleLogInfoExecute(r ApiMonitorCheckGetConsoleLogInfoRequest) (WaterfallResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WaterfallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetConsoleLogInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/ConsoleLog"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.step != nil {
		localVarQueryParams.Add("step", parameterToString(*r.step, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetHttpDetailsRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
}


func (r ApiMonitorCheckGetHttpDetailsRequest) Execute() (HttpDetailsResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetHttpDetailsExecute(r)
}

/*
MonitorCheckGetHttpDetails Returns HTTP details for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetHttpDetailsRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetHttpDetails(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetHttpDetailsRequest {
	return ApiMonitorCheckGetHttpDetailsRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return HttpDetailsResponse
func (a *MonitorCheckApiService) MonitorCheckGetHttpDetailsExecute(r ApiMonitorCheckGetHttpDetailsRequest) (HttpDetailsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HttpDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetHttpDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/Http"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetMonitorCheckRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorGuid string
	errorLevel *string
	showPartialMeasurements *bool
	cursor *string
	sorting *string
	take *int32
	start *time.Time
	end *time.Time
	presetPeriod *string
}

// Error level filter that should be applied. (default &#x3D; NoError and above)
func (r ApiMonitorCheckGetMonitorCheckRequest) ErrorLevel(errorLevel string) ApiMonitorCheckGetMonitorCheckRequest {
	r.errorLevel = &errorLevel
	return r
}
// Show partial measurements from concurrent monitors
func (r ApiMonitorCheckGetMonitorCheckRequest) ShowPartialMeasurements(showPartialMeasurements bool) ApiMonitorCheckGetMonitorCheckRequest {
	r.showPartialMeasurements = &showPartialMeasurements
	return r
}
// A cursor value that should be used for traversing the dataset.
func (r ApiMonitorCheckGetMonitorCheckRequest) Cursor(cursor string) ApiMonitorCheckGetMonitorCheckRequest {
	r.cursor = &cursor
	return r
}
// Sorting direction based on timestamp.
func (r ApiMonitorCheckGetMonitorCheckRequest) Sorting(sorting string) ApiMonitorCheckGetMonitorCheckRequest {
	r.sorting = &sorting
	return r
}
// The number of records to return (Max value &#x3D; 100)
func (r ApiMonitorCheckGetMonitorCheckRequest) Take(take int32) ApiMonitorCheckGetMonitorCheckRequest {
	r.take = &take
	return r
}
// The start of a custom period (can&#39;t be used together with the PresetPeriod parameter)
func (r ApiMonitorCheckGetMonitorCheckRequest) Start(start time.Time) ApiMonitorCheckGetMonitorCheckRequest {
	r.start = &start
	return r
}
// The end of a custom period
func (r ApiMonitorCheckGetMonitorCheckRequest) End(end time.Time) ApiMonitorCheckGetMonitorCheckRequest {
	r.end = &end
	return r
}
// The requested time period.
func (r ApiMonitorCheckGetMonitorCheckRequest) PresetPeriod(presetPeriod string) ApiMonitorCheckGetMonitorCheckRequest {
	r.presetPeriod = &presetPeriod
	return r
}

func (r ApiMonitorCheckGetMonitorCheckRequest) Execute() (MonitorCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetMonitorCheckExecute(r)
}

/*
MonitorCheckGetMonitorCheck Returns monitor check data for a specific monitor.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorGuid The Guid of the monitor to get monitor checks for.
 @return ApiMonitorCheckGetMonitorCheckRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetMonitorCheck(ctx _context.Context, monitorGuid string) ApiMonitorCheckGetMonitorCheckRequest {
	return ApiMonitorCheckGetMonitorCheckRequest{
		ApiService: a,
		ctx: ctx,
		monitorGuid: monitorGuid,
	}
}

// Execute executes the request
//  @return MonitorCheckResponse
func (a *MonitorCheckApiService) MonitorCheckGetMonitorCheckExecute(r ApiMonitorCheckGetMonitorCheckRequest) (MonitorCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MonitorCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetMonitorCheck")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/Monitor/{monitorGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorGuid"+"}", _neturl.PathEscape(parameterToString(r.monitorGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.errorLevel != nil {
		localVarQueryParams.Add("ErrorLevel", parameterToString(*r.errorLevel, ""))
	}
	if r.showPartialMeasurements != nil {
		localVarQueryParams.Add("ShowPartialMeasurements", parameterToString(*r.showPartialMeasurements, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("Cursor", parameterToString(*r.cursor, ""))
	}
	if r.sorting != nil {
		localVarQueryParams.Add("Sorting", parameterToString(*r.sorting, ""))
	}
	if r.take != nil {
		localVarQueryParams.Add("Take", parameterToString(*r.take, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("Start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("End", parameterToString(*r.end, ""))
	}
	if r.presetPeriod != nil {
		localVarQueryParams.Add("PresetPeriod", parameterToString(*r.presetPeriod, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetMonitorGroupDataRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorGroupGuid string
	errorLevel *string
	showPartialMeasurements *bool
	cursor *string
	sorting *string
	take *int32
	start *time.Time
	end *time.Time
	presetPeriod *string
}

// Error level filter that should be applied. (default &#x3D; NoError and above)
func (r ApiMonitorCheckGetMonitorGroupDataRequest) ErrorLevel(errorLevel string) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.errorLevel = &errorLevel
	return r
}
// Show partial measurements from concurrent monitors
func (r ApiMonitorCheckGetMonitorGroupDataRequest) ShowPartialMeasurements(showPartialMeasurements bool) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.showPartialMeasurements = &showPartialMeasurements
	return r
}
// A cursor value that should be used for traversing the dataset.
func (r ApiMonitorCheckGetMonitorGroupDataRequest) Cursor(cursor string) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.cursor = &cursor
	return r
}
// Sorting direction based on timestamp.
func (r ApiMonitorCheckGetMonitorGroupDataRequest) Sorting(sorting string) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.sorting = &sorting
	return r
}
// The number of records to return (Max value &#x3D; 100)
func (r ApiMonitorCheckGetMonitorGroupDataRequest) Take(take int32) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.take = &take
	return r
}
// The start of a custom period (can&#39;t be used together with the PresetPeriod parameter)
func (r ApiMonitorCheckGetMonitorGroupDataRequest) Start(start time.Time) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.start = &start
	return r
}
// The end of a custom period
func (r ApiMonitorCheckGetMonitorGroupDataRequest) End(end time.Time) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.end = &end
	return r
}
// The requested time period.
func (r ApiMonitorCheckGetMonitorGroupDataRequest) PresetPeriod(presetPeriod string) ApiMonitorCheckGetMonitorGroupDataRequest {
	r.presetPeriod = &presetPeriod
	return r
}

func (r ApiMonitorCheckGetMonitorGroupDataRequest) Execute() (MonitorCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetMonitorGroupDataExecute(r)
}

/*
MonitorCheckGetMonitorGroupData Returns monitor check data for a specific monitor group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorGroupGuid The Guid of the monitor group to get monitor checks for.
 @return ApiMonitorCheckGetMonitorGroupDataRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetMonitorGroupData(ctx _context.Context, monitorGroupGuid string) ApiMonitorCheckGetMonitorGroupDataRequest {
	return ApiMonitorCheckGetMonitorGroupDataRequest{
		ApiService: a,
		ctx: ctx,
		monitorGroupGuid: monitorGroupGuid,
	}
}

// Execute executes the request
//  @return MonitorCheckResponse
func (a *MonitorCheckApiService) MonitorCheckGetMonitorGroupDataExecute(r ApiMonitorCheckGetMonitorGroupDataRequest) (MonitorCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MonitorCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetMonitorGroupData")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/MonitorGroup/{monitorGroupGuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorGroupGuid"+"}", _neturl.PathEscape(parameterToString(r.monitorGroupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.errorLevel != nil {
		localVarQueryParams.Add("ErrorLevel", parameterToString(*r.errorLevel, ""))
	}
	if r.showPartialMeasurements != nil {
		localVarQueryParams.Add("ShowPartialMeasurements", parameterToString(*r.showPartialMeasurements, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("Cursor", parameterToString(*r.cursor, ""))
	}
	if r.sorting != nil {
		localVarQueryParams.Add("Sorting", parameterToString(*r.sorting, ""))
	}
	if r.take != nil {
		localVarQueryParams.Add("Take", parameterToString(*r.take, ""))
	}
	if r.start != nil {
		localVarQueryParams.Add("Start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("End", parameterToString(*r.end, ""))
	}
	if r.presetPeriod != nil {
		localVarQueryParams.Add("PresetPeriod", parameterToString(*r.presetPeriod, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetMultistepDetailsRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
}


func (r ApiMonitorCheckGetMultistepDetailsRequest) Execute() (MsaDetailsResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetMultistepDetailsExecute(r)
}

/*
MonitorCheckGetMultistepDetails Returns Multi-Step API details for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetMultistepDetailsRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetMultistepDetails(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetMultistepDetailsRequest {
	return ApiMonitorCheckGetMultistepDetailsRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return MsaDetailsResponse
func (a *MonitorCheckApiService) MonitorCheckGetMultistepDetailsExecute(r ApiMonitorCheckGetMultistepDetailsRequest) (MsaDetailsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MsaDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetMultistepDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/MultiStepAPI"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetPageSourceInfoRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
	step *int32
}

// For transactions only: the transaction step to get the page source for.
func (r ApiMonitorCheckGetPageSourceInfoRequest) Step(step int32) ApiMonitorCheckGetPageSourceInfoRequest {
	r.step = &step
	return r
}

func (r ApiMonitorCheckGetPageSourceInfoRequest) Execute() (WaterfallResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetPageSourceInfoExecute(r)
}

/*
MonitorCheckGetPageSourceInfo Returns page source information for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetPageSourceInfoRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetPageSourceInfo(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetPageSourceInfoRequest {
	return ApiMonitorCheckGetPageSourceInfoRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return WaterfallResponse
func (a *MonitorCheckApiService) MonitorCheckGetPageSourceInfoExecute(r ApiMonitorCheckGetPageSourceInfoRequest) (WaterfallResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WaterfallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetPageSourceInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/PageSource"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.step != nil {
		localVarQueryParams.Add("step", parameterToString(*r.step, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetScreenshotsRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
	screenshotId string
}


func (r ApiMonitorCheckGetScreenshotsRequest) Execute() (ScreenshotResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetScreenshotsExecute(r)
}

/*
MonitorCheckGetScreenshots Gets a specific screenshot for a specified monitor check

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the screenshot data for.
 @param screenshotId The screenshot Id of the screenshot to get.
 @return ApiMonitorCheckGetScreenshotsRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetScreenshots(ctx _context.Context, monitorCheckId int64, screenshotId string) ApiMonitorCheckGetScreenshotsRequest {
	return ApiMonitorCheckGetScreenshotsRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
		screenshotId: screenshotId,
	}
}

// Execute executes the request
//  @return ScreenshotResponse
func (a *MonitorCheckApiService) MonitorCheckGetScreenshotsExecute(r ApiMonitorCheckGetScreenshotsRequest) (ScreenshotResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetScreenshots")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/Screenshot/{screenshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"screenshotId"+"}", _neturl.PathEscape(parameterToString(r.screenshotId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetSingleMonitorCheckRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
}


func (r ApiMonitorCheckGetSingleMonitorCheckRequest) Execute() (SingleMonitorCheckResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetSingleMonitorCheckExecute(r)
}

/*
MonitorCheckGetSingleMonitorCheck Returns a single monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The Id of the monitor check to get the data for.
 @return ApiMonitorCheckGetSingleMonitorCheckRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetSingleMonitorCheck(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetSingleMonitorCheckRequest {
	return ApiMonitorCheckGetSingleMonitorCheckRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return SingleMonitorCheckResponse
func (a *MonitorCheckApiService) MonitorCheckGetSingleMonitorCheckExecute(r ApiMonitorCheckGetSingleMonitorCheckRequest) (SingleMonitorCheckResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleMonitorCheckResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetSingleMonitorCheck")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetTransactionDetailsRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
}


func (r ApiMonitorCheckGetTransactionDetailsRequest) Execute() (TransactionDetailsResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetTransactionDetailsExecute(r)
}

/*
MonitorCheckGetTransactionDetails Returns transaction step details for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetTransactionDetailsRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetTransactionDetails(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetTransactionDetailsRequest {
	return ApiMonitorCheckGetTransactionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return TransactionDetailsResponse
func (a *MonitorCheckApiService) MonitorCheckGetTransactionDetailsExecute(r ApiMonitorCheckGetTransactionDetailsRequest) (TransactionDetailsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TransactionDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetTransactionDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/Transaction"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitorCheckGetWaterfallInfoRequest struct {
	ctx _context.Context
	ApiService *MonitorCheckApiService
	monitorCheckId int64
	step *int32
}

// For transaction waterfalls only: the transaction step to get the waterfall for.
func (r ApiMonitorCheckGetWaterfallInfoRequest) Step(step int32) ApiMonitorCheckGetWaterfallInfoRequest {
	r.step = &step
	return r
}

func (r ApiMonitorCheckGetWaterfallInfoRequest) Execute() (WaterfallResponse, *_nethttp.Response, error) {
	return r.ApiService.MonitorCheckGetWaterfallInfoExecute(r)
}

/*
MonitorCheckGetWaterfallInfo Returns waterfall information for a monitor check.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorCheckId The monitor check Id to get the detailed data for.
 @return ApiMonitorCheckGetWaterfallInfoRequest
*/
func (a *MonitorCheckApiService) MonitorCheckGetWaterfallInfo(ctx _context.Context, monitorCheckId int64) ApiMonitorCheckGetWaterfallInfoRequest {
	return ApiMonitorCheckGetWaterfallInfoRequest{
		ApiService: a,
		ctx: ctx,
		monitorCheckId: monitorCheckId,
	}
}

// Execute executes the request
//  @return WaterfallResponse
func (a *MonitorCheckApiService) MonitorCheckGetWaterfallInfoExecute(r ApiMonitorCheckGetWaterfallInfoRequest) (WaterfallResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WaterfallResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorCheckApiService.MonitorCheckGetWaterfallInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MonitorCheck/{monitorCheckId}/Waterfall"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorCheckId"+"}", _neturl.PathEscape(parameterToString(r.monitorCheckId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.step != nil {
		localVarQueryParams.Add("step", parameterToString(*r.step, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MessageList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
